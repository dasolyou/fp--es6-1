<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>11. 비동기 동시성 프로그래밍 - 3</title>
</head>
<body>
  <script src="./js/js10.js"></script>

  ## async/await
  비동기 상황을 동기적으로 다루려구

  <script>
    function delay(time) {
      return new Promise(resolve => setTimeout(() => resolve(a), time));
    }
    async function delayIdentity(a) {
      await delay(1000);
      return a;
    }
    async function f1() { 
      const a = await delayIdentity(10); // 프로미스 내부에 있는 값이 a에 할당됨
      const b = await delayIdentity(5);
      console.log(a + b);
    }
    // async가 붙으면 내부에 await로 프로미스가 전달이 안 돼도 프로미스를 리턴함
    async function f1() { 
      const a = 10; 
      const b = 5;
      console.log(a + b);
    }
    f1();
  </script>

  ## QnA. Array.prototype.map이 있는데 왜 FxJS의 map 함수가 필요한지?

  <script>
    function delayI(a) {
      return new Promise(resolve => setTimeout(() => resolve(a), 100));
    }

    function f2() {
      const list = [1, 2, 3, 4];
      const res = list.map(a => delayI(a * a));
      console.log(res);
    }
    f2();

    async function f3() {
      const list = [1, 2, 3, 4];
      const res = await map(a => delayI(a * a), list);
      console.log(res);
    }
    f3();
  </script>

  ## QnA. 이제 비동기는 async/await로 제어할 수 있는데 왜 파이프라인이 필요한지?
  async/await: promise.then(함수체인)보다 문장으로 다루기 위해 -> 합성보다 풀어 놓기 위해
  파이프라인: 동기/비동기 상황에서 X, 동기/비동기 상황에 같아보임, 명령형 프로그래밍을 하지 않고 함수 합성을 더욱 안전하게 하기 위해

  <script>
  function f5(list) {
    return go(list,
      L.map(a => delayI(a * a)),
      L.filter(a => delayI(a % 2)),
      L.map(a => delayI(a + 1)),
      C.take(2),
      reduce((a, b) => delayI(a + b)));
  }

  go(f5([1, 2, 3, 4, 5, 6, 7, 8]), a => log(a, 'f5'));

  async function f6() {
    for (const a of list) {
      const b = await delayI(a * a);
      if (b % 2) {
        console.log(b);
      }
    }
  }
  </script>

  ## QnA. async/await와 파이프라인을 같이 사용하기도 하나요?

  <script>
  function f52(list) {
    const r1 = await go(list,
      L.map(a => delayI(a * a)),
      L.filter(a => delayI(a % 2)),
      L.map(a => delayI(a + 1)),
      C.take(2),
      reduce((a, b) => delayI(a + b)));
    
    const r2 = await go(list,
      L.map(a => delayI(a * a)),
      L.filter(a => delayI(a % 2)),
      reduce((a, b) => delayI(a + b)));

    const r3 = await delayI(r1 + r2);
    return r3 + 10;
  }

  go(f52([1, 2, 3, 4, 5, 6, 7, 8]), a => console.log(a, 'f52'));
  </script>

  ## QnA. 동기 상황에서 에러 핸들링은 어떻게 해야하는지?
  undifined은 흘려보내거나 null or을 사용
  비슷한 것을 리턴
  <script>
  function f7(list) {
    try {
      return list
        .map(a => JSON.parse(a))
        .filter(a => a % 2)
        .slice(0, 2);
    } catch (e) {
      log(e);
      return [];
    }
  }
  log(f7(['0', '1', '2', '{']));
  </script>

  ## QnA. 비동기 상황에서 에러 핸들링은 어떻게 해야하는지?

  <script>
  </script>

  ## QnA. 동기/비동기 에러 핸들링에서의 파이프라인의 이점은?

  <script>
  </script>
</body>
</html>