<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>04. map, filter, reduce</title>
</head>
<body>
  <script>
    const products = [
      {name: '반팔티', price: 15000},
      {name: '긴팔티', price: 20000},
      {name: '핸드폰케이스', price: 15000},
      {name: '후드티', price: 30000},
      {name: '바지', price: 25000}
    ];
  </script>
  
  # map
  
  <script>
    // 함수형 프로그래밍에선 함수가 인자와 리턴 값으로 소통하는 것을 권장
    const map = (f, iter) => { // iter: 외부에서 받아오는 값 -> iterable 프로토콜을 따름
      let res = [];
      for (const a of iter) {
        res.push(f(a)); // 직접적이지 않게, 추상적으로! -> 함수를 받아서 그 함수에 어떤 값을 수집할지 위임
      }
      return res;  // 외부 환경에 직접적 영향을 주지 않고 결과를 리턴해서 외부에서 조작할 수 있도록
    }

    // map 함수 이용 X
    // let names = [];
    // for (const p of products) {
    //   names.push(p.name);
    // }
    // let prices = [];
    // for (const p of products) {
    //   prices.push(p.price);
    // }
    // console.log(names);
    // console.log(prices);

    // map 함수 이용 O
    console.log(map(p => p.name, products));
    console.log(map(p => p.price, products));

    // map함수에 보조함수를 통해서 iterable 안에 있는 값 중 일대일로 매핑되는 어떠한 값을 수집할 것인지 결정
    // map함수는 고차함수: 함수를 인자로 받으면서 원하는 시점에 실행 


  </script>
  
  # 이터러블 프로토콜을 따른 map의 다형성
  
  <script>
    // document.querySelectorAll('*')은 배열이 아님, iterable 프로토콜을 따름 -> 배열의 내장 함수 .map 사용 X, 함수형 map 사용 가능

    console.log(map(el => el.nodeName, document.querySelectorAll('*')));

    function *gen() {
      yield 1;
      yield 2;
      yield 3;
      yield 4;
    }
    console.log(map(a => a * a, gen()));

    let m = new Map();
    m.set('a', 10);
    m.set('b', 20);
    // const it = m[Symbol.iterator]();
    // console.log(it.next());
    // console.log(it.next());
    // console.log(it.next());
    console.log(map(([k, a]) => [k, a * 2], m));
    console.log(new Map(map(([k, a]) => [k, a * 2], m))); // 안쪽의 값이 바뀐 맵 객체를 다시 만들 수 있음
  </script>
  
  
  # filter
  
  <script>
    console.clear();
    const filter = (f, iter) => {
      let res = [];
      for (const a of iter) {
        if (f(a)) res.push(a);
      }  
      return res;
    }

    // filter 사용 X
    // let under20000 = [];
    // for (const p of products) {
    //   if (p.price < 20000) under20000.push(p);
    // }
    
    // let over20000 = [];
    // for (const p of products) {
    //   if (p.price <= 20000) over20000.push(p);
    // }
    // console.log(...under20000);
    // console.log(...over20000);

    // filter 사용 O
    console.log(...filter(p => p.price > 20000, products));
    console.log(...filter(p => p.price <= 20000, products));

    console.log(filter(n => n % 2, [1, 2, 3, 4]));

    console.log(filter(n => n % 2, function *() {
      yield 1;
      yield 2;
      yield 3;
      yield 4;
      yield 5;
    } ()));
  </script>
  
  # reduce
  
  <script>
    const nums = [1, 2, 3, 4, 5];
    
    let total = 0;
    for (const n of nums) {
      total = total + n;
    }
    console.log(total);

    const reduce = (f, acc, iter) => {
      if (!iter) {
        iter = acc[Symbol.iterator]();
        acc = iter.next().value; // 초기 값은 iter의 첫번째 값을 가져야 함 
      }
      for (const a of iter) {
        acc = f(acc, a);
      } 
      return acc;
    }

    const add = (a, b) => a + b;
    console.log(reduce(add, 0, [1, 2, 3, 4, 5]));
    console.log(reduce(add, [1, 2, 3, 4, 5])); // 초기값 없이도 동작하도록
    console.log(reduce((total_price, product) => total_price + product.price, 0, products));
  </script>
  
  <script>
    const add2 = (a, b) => a + b;
    console.log(
      reduce(add2, 
        map(p => p.price, 
          filter(p => p.price < 20000, products)
        )
      )
    );
    console.log(
      reduce(add2, 
        filter(n => n < 20000, 
          map(p => p.price, products)
        )
      )
    );
  </script>
  
</body>
</html>