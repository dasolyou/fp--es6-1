<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>07. 지연성 1 - 2</title>
</head>
<body>
  <!-- <script src="./js/fx.js"></script> -->
  <script>
    const L = {};
    const curry = f => (a, ..._) =>_.length ? f(a, ..._) : (..._) => f(a, ..._);
    const go = curry((...args) => reduce((a, f) => f(a), args)); 
    const pipe = (f, ...fs) => (...as) => go(f(...as), ...fs);
  </script>

  # 이터러블 중심 프로그래밍에서의 지연 평가 (Lazy Evaluation)
  - 제때 계산법
  - 느긋한 계산법
  - 제너레이터/이터레이터 프로토콜을 기반으로 구현

  ### L.map

  <script>
    L.map = function *(f, iter) {
      for (const a of iter) yield f(a);
    };
    var it = L.map(a => a + 10, [1, 2, 3]);

    // 평가를 하지 않으면 아무 일도 일어나지 않음
    // console.log([...it]); // [11, 12, 13]
    // console.log([it.next().value]); 
    // console.log(it.next());
    // console.log(it.next());
  </script>

  ### L.filter

  <script>
    L.filter = function *(f, iter) {
      for (const a of iter) if (f(a)) yield a;
    };
    var it = L.filter(a => a % 2, [1, 2, 3, 4]);
    // console.log(it.next());
  </script>


  ### range, map, filter, take, reduce 중첩 사용

  <script>
    const range = l => {
      let i = -1;
      let res = [];
      while (++i < l) {
        res.push(i);
      }
      return res;
    };

    const map = curry((f, iter) => {
      let res = [];
      iter = iter[Symbol.iterator]();
      let cur;
      while (!(cur = iter.next()).done) {
        const a = cur.value;
        res.push(f(a)); 
      }
      // for (const a of iter) {
      //   res.push(f(a)); 
      // }
      return res; 
    })

    // filter(조건함수, iterator)
    const filter = curry((f, iter) => {
      let res = [];
      iter = iter[Symbol.iterator]();
      let cur;
      while (!(cur = iter.next()).done) {
        const a = cur.value;
      // for (const a of iter) {
        if (f(a)) res.push(a);
      }  
      return res;
    })

    // reduce(reduce하려는 함수, 초기값, iterator)
    const reduce = curry((f, acc, iter) => {
      if (!iter) {
        iter = acc[Symbol.iterator]();
        acc = iter.next().value;
      } else {
        iter = iter[Symbol.iterator]();
      }
      let cur;
      while (!(cur = iter.next()).done) {
        const a = cur.value;
      // for (const a of iter) {
        acc = f(acc, a);
      } 
      return acc; 
    })
    
    const take = curry((l, iter) => {
      let res = [];
      iter = iter[Symbol.iterator]();
      let cur;
      while (!(cur = iter.next()).done) {
        const a = cur.value;
      // for (const a of iter) {
        res.push(a);
        if (res.length == l) return res;
      }
      return res;
    });

    // console.time('');
    go(range(10000),
      map(n => n + 10),
      filter(n => n % 2),
      take(10),
      console.log 
    )
    // console.timeEnd('');

  </script>

  ### L.range, L.map, L.filter, take, reduce 중첩 사용

  <script>
    L.range = function *(l) {
      let i = -1;
      while (++i < l) {
        yield i;
      }
    };

    L.map = curry(function *(f, iter) {
      iter = iter[Symbol.iterator]();
      let cur;
      while (!(cur = iter.next()).done) {
        const a = cur.value;
        yield f(a);
      }
    });

    L.filter = curry(function *(f, iter) {
      iter = iter[Symbol.iterator]();
      while (!(cur = iter.next()).done) {
        const a = cur.value;
        if (f(a)) {
          yield a;
        }
      }
    });

    // console.time('L');
    go(L.range(Infinity),
      L.map(n => n + 10),
      L.filter(n => n % 2),
      take(10),
      console.log 
    )
    // console.timeEnd('L');
  </script>

  ### map, filter 계열 함수들이 가지는 결합 법칙

  - 사용하는 데이터가 무엇이든지
  - 사용하는 보조 함수가 순수 함수라면 무엇이든지
  - 아래와 같이 결합한다면 둘 다 결과가 같다.

  가로로 가는 즉시 평가 함수 
  [[mapping, mapping], [filtering, filtering], [mapping, mapping]]
  =
  세로로 가는 지연 평가 함수
  [[mapping, filtering, mapping], [mapping, filtering, mapping]]


  map, filter는 지연성을 가질 수 있지만 
   reduce, take는 연산을 시작하는 지점을 알리는 함수라고 할 수 있음
  -> 연산을 시작하거나 종료하거나 다음 로직으로 가는 포인트
  
  ## 결과를 만드는 함수 reduce, take

  ### reduce

  <script>
    const querStr = pipe(
      Object.entries,
      map(([k, v]) => `${k} = ${v}`),
      reduce((a, b) => `${a}&${b}`)
    );
    console.log(querStr({ limit: 10, offset: 10, type: 'notice' }));
  </script>

  ### take, find

  <script>

  </script>
</body>
</html>